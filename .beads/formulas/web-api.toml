name = "web-api"
description = "Create issue for API endpoint implementation"

[[params]]
name = "endpoint_name"
description = "Name of the API endpoint (e.g., 'users', 'posts')"
required = true

[[steps]]
type = "create-issue"
template = """
title: "Implement /api/{{ .endpoint_name }} API endpoint"
description: |
  API endpoint implementation checklist.

  ## API Design
  - [ ] Define HTTP method (GET, POST, PUT, DELETE, PATCH)
  - [ ] Define route path: `/api/{{ .endpoint_name }}`
  - [ ] Define request schema (Zod validation)
  - [ ] Define response schema (TypeScript types)
  - [ ] Plan authentication/authorization requirements
  - [ ] Consider rate limiting needs
  - [ ] Document expected status codes

  ## Implementation
  - [ ] Create route file in `app/api/{{ .endpoint_name }}/route.ts`
  - [ ] Add request validation with Zod
  - [ ] Implement business logic
  - [ ] Add database queries (Prisma)
  - [ ] Handle errors with proper HTTP status codes
    - 200: Success
    - 201: Created
    - 400: Bad Request (validation errors)
    - 401: Unauthorized
    - 403: Forbidden
    - 404: Not Found
    - 500: Internal Server Error
  - [ ] Add TypeScript types for request/response
  - [ ] Add rate limiting if needed
  - [ ] Implement pagination if returning lists

  ## Request/Response Format
  - [ ] Use consistent response structure:
    ```typescript
    { data: T } // Success
    { error: string, details?: any } // Error
    ```
  - [ ] Parse request body: `await request.json()`
  - [ ] Parse query params: `request.nextUrl.searchParams`
  - [ ] Return `Response.json(data, { status: code })`

  ## Security
  - [ ] Validate all inputs (never trust client)
  - [ ] Check authentication (verify JWT/session)
  - [ ] Check authorization (user has permission)
  - [ ] Sanitize outputs (prevent XSS)
  - [ ] Add CSRF protection if needed
  - [ ] Use parameterized queries (Prisma handles this)
  - [ ] Don't expose sensitive data in responses
  - [ ] Add rate limiting for public endpoints

  ## Database Queries
  - [ ] Use Prisma for type-safe queries
  - [ ] Handle database errors gracefully
  - [ ] Use transactions for multi-step operations
  - [ ] Optimize queries (avoid N+1 problems)
  - [ ] Add proper indexes if needed

  ## Testing
  - [ ] Write integration tests
  - [ ] Test success cases (200, 201)
  - [ ] Test error cases (400, 401, 403, 404, 500)
  - [ ] Test edge cases (empty data, invalid input)
  - [ ] Test authentication/authorization
  - [ ] Test with curl or Postman/Thunder Client
  - [ ] Test rate limiting if implemented

  ## Documentation
  - [ ] Add JSDoc with example request/response
  - [ ] Document in API docs (if exists)
  - [ ] Add OpenAPI/Swagger spec if project uses it
  - [ ] Document authentication requirements
  - [ ] Document rate limits

  ## Example Test Commands
  ```bash
  # GET request
  curl http://localhost:3000/api/{{ .endpoint_name }}

  # POST request
  curl -X POST http://localhost:3000/api/{{ .endpoint_name }} \
    -H "Content-Type: application/json" \
    -d '{"key": "value"}'

  # With authentication
  curl http://localhost:3000/api/{{ .endpoint_name }} \
    -H "Authorization: Bearer <token>"
  ```

  ## Code Quality
  - [ ] No TypeScript errors
  - [ ] No linting errors
  - [ ] Code formatted with Prettier
  - [ ] Follows RESTful conventions
  - [ ] Error messages are helpful

  ## Completion
  - [ ] All tests pass
  - [ ] Endpoint returns correct data
  - [ ] Errors handled gracefully
  - [ ] Security checked
  - [ ] Code committed and pushed

tags: [web, api, backend, nextjs, rest]
"""
